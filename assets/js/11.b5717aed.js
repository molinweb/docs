(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{173:function(e,t,n){"use strict";n.r(t);var c=n(0),x=Object(c.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("p",[e._v("exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。\n如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本\n，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），\n第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），\n以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。\ninput 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。\n但是，当 RegExpObject 是一个全局正则表达式时，\nexec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。")]),e._v(" "),n("p",[e._v("1、当正则表达式无子表达式，并且定义为非全局匹配时，exec和match执行的结果是一样，均返回第一个匹配的字符串内容；")]),e._v(" "),n("p",[e._v("2、当正则表达式无子表达式，并且定义为全局匹配时，exec和match执行，做存在多处匹配内容，则match返回的是多个元素数组；")]),e._v(" "),n("p",[e._v("3、当正则表达式有子表示时，并且定义为非全局匹配，exec和match执行的结果是一样；")]),e._v(" "),n("p",[e._v("4、当正则表达式有子表示时，并且定义为全局匹配，exec和match执行的结果不一样，此时match将忽略子表达式，只查找全匹配正则表达式并返回所有内容；")])])}],!1,null,null,null);t.default=x.exports}}]);